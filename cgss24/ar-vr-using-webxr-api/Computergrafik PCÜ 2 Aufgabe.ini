Computergrafik PCÜ 2 Aufgabe
Schritt 1: Transformationen in OpenGL
Wir erinnern uns an die letzte Übung, starten wieder VS Code mit dem alten Verzeichnis, öffnen ch3/ex2_part1/index.html und starten den Debugger. (In der Präsenzübung können wir gerne nochmal den Code des gesamten Programms von der letzten Übung durchgehen.)

Falls im Browser nichts angezeigt wird, müssen wir evtl. index.js.js in index.js umbenennen. (Dies schein ein kleiner Fehler im aktuellen Github-Repo zu sein.)

Wir sehen nun: Das WebGL-Script ist in eine separate Datei ausgelagert worden. Diese schauen wir uns nun an.

Einige Variablen wurden umbenannt. firstSquare hat nun auch z-Werte. Auch bei z wird in OpenGL nur der Wertebereich von -1 bis 1 angezeigt („Clip space“), mehr dazu später.

Bei „gl.vertexAttribPointer(" findet sich nun eine 3 vor gl.Float, es werden also immer drei Floatingpoint-Zahlen aus unserem Buffer gelesen, um sie zu transformieren.
Bei gl.drawArrays ist nun „gl.TRIANGLES" eingestellt, es werden nun die gesamten sechs Punkte aus dem Buffer abgerufen, um zwei Dreiecke zu zeichnen. Die beiden Dreiecke teilen sich also keine Eckpunkte mehr, was theoretisch durch höheren Aufwand die Laufzeit beeinträchtigen könnte.

Aufgabe/Frage a) 

Warum ist das Rechteck eigentlich rot?

Nun die nächste Datei öffnen: ch3/ex2_part1/index.html und im Debugger starten.
Wir sehen zwei unterschiedlich gefärbte Rechtecke voreinander.
Statt „firstSquare“ haben wir nun das Array „squares“, in dem zwei Rechtecke beschrieben sind.
Wir können die Fragentfarbe nicht mehr fest im Fragmentshader verdrahten, stattdessen müssen die Farben den Dreiecken zugeordnet werden.
In lesson2-2.js gibt es dafür ein extra Array „squareColors“. Wir sehen, dass genau analog zu den Eckpunkten auch die Farben in einen Buffer der Grafikkarte geschrieben werden, der durch „colorbuffer“ referenziert werden kann.

Wir sehen weiter unten im Code auch einen analogen Block zur Übertragung der Farben in den Shader. Im Vertexshader gibt es nun zwei Attribute „aPosition“ und „aVertexColor“. Im Vertexshader wird mit „vColor = aVertexColor;“ die Farbe pro Eckpunkt über den Rasterer an den FragmentShader weitergereicht, der dort eine Zeile „varying lowp vec4 color;“ deklariert. Diese Farbe wird dann in die Pixel des Bildspeichers geschrieben.

Exkurs: Achtung im Beispiel wird eine ältere Version von GLSL verwendet. Bei neueren Beispielen könnte die Shader-Syntax anders aussehen. Um neueres GLSL verwenden zu können, müssten wir canvas.getContext('webgl2')  statt nur 'webgl' aufrufen. Ab OpenGL ES 3 sollte man dann im Vertexshader statt „varying“ „out“ und im Fragmentshader statt „varying“ “in“ verwenden.  Außerdem müssten wir am Anfang der Shader die Zeilen: „#version 300 es“ einfügen. Statt „attribute“ müssten wir „in“ schreiben und die Genauigkeit generell mit den Zeilen „precision mediump float;“ festlegen statt individuell mit „lowp“. Am Ende müssen wir statt „gl_Fragcolor“ eine eigene out-Variable „color“ deklarieren, der wir die Farbe zuweisen. Sie können die Umstellung optional als Übung vornehmen.

Aufgabe b) 

Ändern Sie die Einträge im Feld squareColors, so dass sich zwei nachfolgende Zeilen möglichst immer unterscheiden. Wie sieht es jetzt aus ?

Aufgabe c) 

Wenn die Rechtecke „bunt“ genug sind, vertauschen Sie bitte Farben und Eckpunkte und beobachten Sie was passiert. (Hinweis: Das kann an unterschiedlichen Stellen passieren.)

Man kann also beliebig Daten aus Buffern in Shadervariablen einspeisen und muss deshalb darauf achten, dass Shader und WebGL-Programm zusammenpassen. Man kann also nicht einen fremden Shader problemlos in ein eigenes WebGL-Programm integrieren.


Aufgabe d) 

Es gibt noch zwei Zeilen:
gl.enable(gl.DEPTH_TEST);
gl.depthFunc(gl.LEQUAL);

Kommentieren Sie bitte die erste aus und schauen Sie was passiert ? Was zeichnet das Rechteck aus, das jetzt vorne ist ?

Mit der Einstellung gl.DEPTH_TEST wird der Z-Buffer benutzt, um auf Pixelebene zu prüfen, was vorne und was hinten ist bzw. wer was verdeckt.

Bei Verwendung des z-Buffers muss dieser unbedingt pro Bild auch gelöscht werden:
gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

Aufgabe e)


Bei der Verdeckungsbehandlung könnten wir auch festlegen:
gl.depthFunc(gl.GREATER);


Schauen Sie was passiert. Es ist nichts zu sehen, da alle Pixel kleinere z-Werte haben als der gelöschte z-Buffer, so dass nichts „durchgelassen“ wird.

(Verdeckung wird in der 5. Vorlesung genauer betrachtet.)

In der zweiten Vorlesung haben wir uns mit Transformationen beschäftigt. Dies wollen wir nun anwenden, um ein Objekt drehen zu lassen.

Öffnen Sie dazu die Datei „ch4/index.html“. Dort wird am Ende ein Script „gl-matrix-min.js“ von einer externen Website referenziert, das geometrische Transformationen implementiert. Generell kann man von überall her Script-Dateien verlinken auf die Gefahr hin, dass diese Dateien zwischenzeitlich verändert werden, so dass die eigene Anwendung dann möglicherweise nicht mehr funktioniert. Um dies auszuschließen, kann man einen „Subresource Integrity“-Hashcode generieren lassen und im Feld „integrity“ angeben. Dann würde der Browser ggf. merken, dass die verlinkte Datei nicht mehr dem Hashcode entspricht.

In unserer „index.html“ ist zunächstdie Datei „lesson3-1.js“ referenziert, die wir uns nun genauer anschauen.
Die erste Veränderung sehen wir im Vertexshader. Dort gibt es nun zusätzlich die Zeile: 

uniform mat4 uModelViewMatrix;
Das Wort „uniform“ charakterisiert die Variable als konstant während ein Buffer verarbeitet wird, Eine uniform-Variable kann von außen gesetzt/verändert werden, bevor der Buffer (z.B. mit gl.drawArrays) eingespeist/verarbeitet wird.

Wir wollen das gesamte Objekt mit allen seinen Eckpunkten drehen, alle Punkte sollen mit der gleichen Rotationsmatrix transformiert werden, wir müssen sie also von außen vorher setzen.
Wir sehen, dass im Shader alle Eckpunkte (eingespeist in „aPosition“) jeweils mit dem Wert uModelViewMatrix transformiert werden.
Die nächsten Änderungen sehen wir ab der Zeile: „let cubeRotation = 0.0;"

Einige Befehlsaufrufe sind jetzt aus der „main“ in eine Funktion „render“ verschoben worden. Während „main“ nur einmal aufgerufen wird/wurde, soll sich der Bildschirminhalt ja nun permanent verändern. Dashalb werden die Befehle nun innerhalb einer Schleife aufgerufen.
Den Schleifenrumpf dürfen wir in Javascript jedoch nicht direkt aufrufen, da sonst das Programm blockieren würde. Sattdessen verwendet man die Funktion requestAnimationFrame(). Sie erlaubt es dem Browser darüber hinaus nicht sichtbare Fenster zu pausieren. Beim Aufruf bekommen wir einen Zeitstempel mit, so dass wir ein deltaT zum letzten Aufruf berechnen können. Wir rufen die Funktion enmal initial und dann am Ende des Schleifenrumpfs auf, um das nächste Bild zu generieren.

Die Berechnung der Rotationsmatrix und Übertragung an den Shader sehen wir in den Zeilen 145 bis 154. Zunächst müssen wir uns wieder den Zugriff auf eine Variable im Shader verschaffen („gl.getUniformLocation“), dann mit den Funktionen aus gl-Matrix.js eine variable Rotationsmatrix bestimmen „mat4.rotate(", und diese dann an den Shader übertragen („gl.uniformMatrix4fv(") bevor, das Objekt gerendert wird. Die Variable „cube Rotation“ verändert sich von Frame zu Frame.

Aufgabe f) 

Verändern Sie die Drehgeschwindigkeit und lassen Sie das Objekt um eine andere, schräge Achse drehen.


Schritt 2: Projektion

Die ModelView-Matrix ist das Produkt aus Modelmatrix und Viewmatrix, die Begriffe sollten Ihnen aus der Vorlesung noch vertraut sein.

Nun wechseln wir die Datei: In „index.html“ muss nun statt „lesson3-1.js“ „lesson3-2.js“ referenziert werden.

Was hat sich geändert ? Es ist die ProjectionMatrix hinzugekommen. Das sehen wir im Vertexshader und ab der Zeile:  „const projMatrixLocation = gl.getUniformLocation(program, 'uProjectionMatrix');“ Wir verwenden dazu wieder eine Funktion aus gl-matrix-min.js.

Damit die Szene bzw. das Objekt nun noch sichtbar ist, muss die Szene nach hinten verschoben werden, das übernimmt „mat4.translate(modelViewMatrix, …“.

Aufgabe g) 

Verändern Sie die Parameter von „mat4.perspective", so dass die Szene verschwindet oder anders dargestellt wird. Stellen Sie am Ende bitte wieder den Originalzustand her.

Aufgabe h) 

Jetzt kommen wir zur letzten Aufgabe mit purem OpenGL.

Die Szene wird zurzeit animiert dargestellt. Stattdessen ändern Sie das Programm bitte so, dass man das Objekt interaktiv drehen kann. Dazu können Sie folgenden Code verwenden:

    let angleX = 0;

    let angleY = 0;

    let angleZ = 0;

    function checkKey(event) {

        console.log(event.keyCode);

       switch (event.keyCode) {

            case 88 /*"KeyX"*/: angleX += 0.1; break;

            case 89 /*"KeyY"*/: angleY += 0.1; break;

            case 90 /*"KeyZ"*/: angleZ += 0.1; break;

        }

    }

-------------------

    mat4.rotate(modelViewMatrix, modelViewMatrix, angleX, [1, 0, 0]);      

    mat4.rotate(modelViewMatrix, modelViewMatrix, angleY, [0, 1, 0]);      

    mat4.rotate(modelViewMatrix, modelViewMatrix, angleZ, [0, 0, 1]);      

------------------

   window.onkeydown = checkKey;

Ihre Aufgabe besteht nun darin, die richtigen Stellen im Programm zu finden, wo die Codefragmente hinkommen müssen und außerdem zu entscheiden, welche Befehlsaufrufe dafür entfernt werden sollten.

Wenn alles geklappt hat, können Sie den Würfel um drei Achsen (x-, y- und z-Achse) drehen. Sie können dabei auch die Nachteile der Steuerung mit Eulerwinkeln nachvollziehen. Was könnte aus Benutzerperspektive besser sein ?

An dieser Stelle sind wir hoffentlich am Ende der zweiten Übung. Sollten wir schneller sein, können wir auch schon mit der nächsten Übung weitermachen. Falls wir langsamer sind, kommen wir an diese Stelle erst beim nächsten Termin. Merken Sie sich auf alle Fälle, was Sie getan haben und sichern Sie Ihre Arbeit.